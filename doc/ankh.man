[comment {-*- tcl -*- doctools manpage}]
[include include/version.inc]
[manpage_begin [vset PROJECT_lc] n [vset VERSION]]
[include include/module.inc]
[titledesc "[vset PROJECT] - API"]
[description]
[include include/welcome.inc]

[para] This document is the reference manpage for the publicly visible API,
i.e. the API a user will see, and use.

[comment {* * ** *** ***** ******** ************* *********************}]
[section {Global operations}]

[list_begin definitions]

[call [cmd {ak hash version}]]

This command returns a string containing the version number of the
[package [vset PROJECT]] package.

[call [cmd {ak hash list}]]

This command returns a list containing the names of all the hashes
supported by the [package [vset PROJECT]] package. The names are
returned in dictionary order.

[list_end]

[comment {* * ** *** ***** ******** ************* *********************}]
[section {Hash commands}]

Each supported hash provides an ensemble command with three methods
for hashing data from an in-memory string, an open channel, or a file
specified by its path in the filesystem.

[para] The set of supported hashes is described in the following section.

[list_begin definitions]

[call [cmd {ak hash}] [method HASH] [cmd channel] [arg channel] [opt [arg options]]]
[call [cmd {ak hash}] [method HASH] [cmd path] [arg path] [opt [arg options]]]
[call [cmd {ak hash}] [method HASH] [cmd string] [arg string] [opt [arg options]]]

These three commands return the [method HASH]-specific digest of the
data specified by the command arguments.

[para][strong Attention]: Note that this result is binary data, i.e. a
Tcl ByteArray value. It is the callers responsibility to encode this
digest into any other required form, like hex-digits, or base64, etc.

[para] The data to hash (the [term input]) is provided either by a
[arg channel] opened for reading, the [arg path] to a file in the
filesystem, or an in-memory [arg string] (Again a Tcl ByteArray
value).

[para] The [arg options] allow for finer control of the slice of the
input to be hashed.

For more details see section [sectref {Slice Options}].

[para] Notes about [arg channel] handling:

[list_begin itemized]

[item] The input starts at the current location of the channel.

[item] The channel location is moved forward as part of skipping the
       offset, and during hashing itself.

[item] The channel location is left where it is when hashing
       ends. This may be after the end of the channel.

[item] The channel is [strong not] closed by the command.

[list_end]

[call [cmd {ak hash}] [method HASH] [cmd size]]

This command returns the size of digests generated by the
[method HASH], in bytes.

[call [cmd {ak hash}] [method HASH] [cmd references]]

This command returns a list of informational strings about the
[method HASH].

[list_end]

[comment {* * ** *** ***** ******** ************* *********************}]
[section {Slice Options}]

The slice options allow for finer control of the part of the input to
be hashed.

[list_begin options]
[opt_def -offset {wideint > 0}]

Offset in bytes after the start of the input to start hashing from.

If the offset indicates a location after the end of the input then the
[option -length] setting is ignored, and the hash returned is for the
empty string.

[opt_def -length {wideint > 0}]

Length in bytes of the part of the input to hash. If offset and length
indicate a location after the end of the input the hashing terminates
at the end of the input.

[list_end]

[para] For string hashing these options are technically superfluous as
their effect can be had by applying a [cmd {string range}] to the input
before handing it to the hash command.

[para] Similarly for hashing a channel, seeking to the desired
position makes option [option -start] superfluous.

[para] Only for hashing a file both are required if we do not wish to
go through a channel or string at Tcl level.

[para] They are implemented for all modes for the sake of consistency.

[comment {* * ** *** ***** ******** ************* *********************}]
[section {Supported Hashes}]

The package currently supports 18 different hash functions, some
configured for multiple digest sizes, for 30 base commands. Times the
3 modes per such and the package publishes a total of 90 hash
commands.

[para] Note that many of the hash functions have descriptions at
[uri http://rhash.sourceforge.net/hashes.php {RHash @ SourceForge}].
Because of that the descriptions here are even shorter summaries.

[para] Further note that all phrases like
[const {X supports digests of size A, B, ...}]
should be read to mean that this are the digest sizes supported by the
C code underlying [vset PROJECT].

While this matches the allowed/specified digest sizes for many of the
hashes here, it is not true for all.

[list_begin definitions]
[def [const aich]]

The [term {Advanced Intelligent Corruption Handler}] comes from the
[term EDonkey] p2p-network. It uses SHA-1 internally. Digests are 160
bits.

[para] See also [term ed2k] below.

[def [const blake]]

See [uri https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2 {Blake 2 @ Wikipedia}] for details.
Supports digests of 256 and 512 bits.

[list_begin definitions]
[def [const blake2b]]
[def [const blake2s]]
[list_end]

[def [const btih]]

The [term {BitTorrent InfoHash}] originates, naturally, in the
BitTorrent network. Digests are 160 bits.

[def [const ed2k]]

Like [term aich] above [term {EDonkey 2000}] comes from the
[term EDonkey] p2p-network. It uses MD-4 internally. Digests are 128
bits.

[def [const edonr]]

Defined in 2006 in the article
[term {D. Gligoroski, S. Markovski, L. Kocarev "Edon-R, An Infinite Family of Cryptographic Hash Functions"}].
Supports digests of 224, 256, 384, and 512 bits.

[list_begin definitions]
[def [const edonr/224]]
[def [const edonr/256]]
[def [const edonr/384]]
[def [const edonr/512]]
[list_end]

[def [const gost12]]
[def [const gost94]]

These hash functions are from the Russian national standard
[term {GOST R 34.11-94}].
[term gost12] supports digests of 256 and 512 bits.
[term gost94] digests are 256 bits.

[list_begin definitions]
[def [const gost12/256]]
[def [const gost12/512]]
[def [const gost94]]
[list_end]

[def [const has160]]

Designed in and by Korea, for the
[term {Korean Certificate-based Digital Signature Algorithm}] (KCDSA).
Digests have 160 bits.

[def [const md4]]

[term {Message digest 4}] was developed by Ronald L. Rivest.
See RFC 1320.
Digests have 128 bits.

[def [const md5]]

[term {Message digest 5}] is an improved success of MD-4, also
developed by Ronald L. Rivest.
See RFC 1321.
Digests have 128 bits.

[def [const ripemd160]]

The [term {RACE Integrity Primitives Evaluation Message Digest}].
Digests have 160 bits.

[def [const sha1]]

The [term {Secure Hash Algorithm 1}] was designed in 1993.
See RFC 3174.
Digests are 160 bits.

[def [const sha2]]

[term {Secure Hash Algorithm 2}] is the successor of SHA-2.
Supports digests of 224, 256, 384, and 512 bits.

[list_begin definitions]
[def [const sha2/224]]
[def [const sha2/256]]
[def [const sha2/384]]
[def [const sha2/512]]
[list_end]

[def [const sha3]]

[term {Secure Hash Algorithm 3}] is the latest in the SHA series.
Based on a completely new internal construction than the predecessors.
See [term KECCACK].
Supports digests of 224, 256, 384, and 512 bits.

[list_begin definitions]
[def [const sha3/224]]
[def [const sha3/256]]
[def [const sha3/384]]
[def [const sha3/512]]
[list_end]

[def [const snefru]]

Made by Ralph Merkle in 1990.  Considered broken. Also slow.
Supports digests of 128 and 256 bits.

[list_begin definitions]
[def [const snefru/128]]
[def [const snefru/256]]
[list_end]

[def [const tiger]]

Tiger was developed by Ross Anderson and Eli Biham, with speed on
64bit processors in mind.
Digests are 192 bits.

[def [const tth]]

The [term {Tiger Tree Hash}] is based on the [term Tiger] hash above.
It is used by the p2p networks [term {Direct Connect}] and [term Gnutella].
Digests are 512 bits.

[def [const whirlpool]]

Comes from [term NESSIE]. Adopted by [term {ISO/IEC 10118-3:2004}].
Digests are 512 bits.

[list_end]

[comment {
    - - -- --- ----- -------- ------------- ---------------------

A Hash Function is an algorithm that converts a long string (or
message) of any length into a fixed length string known as Message
Digest, checksum or digital fingerprint.

CRC32 (Cyclic redundancy check) is simple hash function designed to
protect data from accidental changes in computer devices such as
network cards and hard disk drives. It is specified in the CRC32-IEEE
802.3 standard. The algorithm while being totaly insecure is very fast
and is still widely used due to its simplicity and speed. The 32-bit
long hash value is a hexadecimal number of 8 characters.

MD4 is a Message Digest Algorithm developed by Ronald L. Rivest from
RSA Data Security, Inc. Currently it's considered insecure, but it's
very fast on 32-bit mashines and it's used for calculating EDonkey
2000 hashes in the EDonkey p2p network. MD4 algorithm is described in
RFC 1320. Hash is a hexadecimal string of 32 characters.

MD5 is another Message Digest Algorith developed by Ronald L. Rivest
from RSA Data Security, Inc. It's an improved version of MD4. The
algorithm is described in RFC 1321. It was an Internet Standart for
years, but now it's considered broken. Hash is a hexadecimal string of
32 characters.

SHA1 (Secure Hash Algorithm 1) is a Hash Function designed by NSA in
1993. It's described in RFC 3174. It's approximately two-three times
slower then MD5 algorithm. Hash is a hexadecimal string of 40
characters.

Tiger is a modern Hash Function developed by Ross Anderson and Eli
Biham. It's designed to be fast on 64-bit processors. See
Description. Hash length is 48 hexadecimal digits.

TTH (Tiger Tree Hash) is used in several P2P networks such as Direct
Connect and Gnutella. TTH is a calculated in a tree-form algorithm
based on Tiger hash, see description. The hash is a base32 encoded
string consisting of 39 alphanumeric symbols.

BTIH (BitTorrent InfoHash) used in BitTorrent network. This hash sum
depends not only on file data, but also on file name and even the
program calculating the hash. RHash uses the same method as
uTorrent. The hash is a string of 40 hexadecimal digits.

EDonkey 2000 is one of the fastest hash functions. It is based on
deprecated MD4 algorithm and is used in the EDonkey p2p network. See
EDonkey network article for details. Hash is a hexadecimal string of
32 characters.

AICH (Advanced Intelligent Corruption Handler) is a hash used in
EDonkey p2p-network and usually included in EDonkey-links. It is
calculated in a bynary-tree form using SHA1 algorithm, see
description. The hash is a base32 encoded string of 32 alphanumeric
symbols.

WHIRLPOOL is a hash function recommended by the NESSIE project and
adopted by ISO/IEC 10118-3:2004 international standard. Hash is
represented as a 128-digit hexadecimal number.

GOST is a hash function defined in Russian national standard GOST R
34.11-94. It has two widely used versions with "test" parameters and
CryptoPro ones. It's relatively slow, but it is used for digital
signature in Russian State banks and enterprises. Hash is a
hexadecimal string of length 64.

HAS-160 is Korean hash sum, designed for Korean Certificate-based
Digital Signature Algorithm (KCDSA). Hash is a hexadecimal string of
length 40.

RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest) is a
160-bit hash function. Specification: The RIPEMD-160 page. Hash is a
hexadecimal string of length 40.

EDON-R is a family of hash functions with variable output
length. RHash supports 256-bit and 512-bit variants. 512-bit EDON-R is
one of fastest hash algorithms on 64-bit processors. The function is
defined in the article: D. Gligoroski, S. Markovski, L. Kocarev
Edon-R, An Infinite Family of Cryptographic Hash Functions
(2006). 256-bit and 512-bit hashes are hexadecimal strings of length
64 and 128, respectively.

Snefru hash function, invented by Ralph Merkle in 1990, is named after
Egyptian Pharaoh Sneferu. It is currently considered broken and is
very slow in comparision to modern hashes. The hash of 128-bit and
256-bit Snefru is represented as a hexadecimal string of length 32 and
64, respectively.

    - - -- --- ----- -------- ------------- ---------------------
}]


[include include/feedback.inc]
[manpage_end]

